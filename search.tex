\documentclass{beamer}

\usepackage{beamerthemesplit} % // Activate for custom appearance

\usepackage{xeCJK}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{algpseudocode}
\usepackage{listings}

\lstset
{
  breaklines=true,
  breakatwhitespace=true,
}

\definecolor{nthu}{HTML}{7F1084}
\definecolor{secondary}{HTML}{910A17}
\definecolor{accent}{HTML}{410A91}
\definecolor{bg}{HTML}{171717}

\setbeamercolor{normal text}{fg=white, bg=bg}
\setbeamercolor{alerted text}{fg=secondary}
\setbeamercolor{example text}{fg=accent}
\setbeamercolor{background}{parent=normal text}
\setbeamercolor{background canvas}{parent=background}
\setbeamercolor{palette primary}{fg=white, bg=secondary}
\setbeamercolor{palette secondary}{use=structure, fg=white, bg=nthu}
\setbeamercolor{palette tertiary}{use=structure, fg=white, bg=accent}
\setbeamercolor{block title}{fg=white, bg=nthu!69!accent}
\setbeamercolor{block body}{fg=white, bg=accent!69!nthu}
\setbeamercolor{titlelike}{fg=white, bg=nthu}
\setbeamercolor{structure}{fg=nthu!64}
\usebeamercolor{structure}
%\usecolortheme[named=nthu]{structure}
\useinnertheme{rounded}
\useoutertheme{infolines}
\usefonttheme{serif}

\xeCJKsetup{CJKglue=\hspace{0pt plus .12 \baselineskip }}
\xeCJKsetup{RubberPunctSkip=false}
\xeCJKsetup{PunctStyle=plain}
\xeCJKsetup{CheckSingle=true}
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 2pt

\setCJKmainfont{Songti TC}
\setCJKsansfont{Apple LiGothic}
\setmonofont{Cascadia Code PL}

\title{搜尋演算法與資料結構}
\subtitle{二分搜尋、二元搜尋樹⋯}
\author{nevikw39}
\institute{點石學園}
\date{\today}

\AtBeginSection{
	\frame
	{
%		\frametitle{Outline}
		\sectionpage
		\tableofcontents[sectionstyle=show/shaded, subsectionstyle=show/show/shaded, subsubsectionstyle=show/show/show/hide]
	}
}

\begin{document}

\frame{\titlepage}

\frame{\tableofcontents}

\section{Abstract}

\frame
{
	\frametitle{Introduction to Searching}
	
	\begin{definition}[Search]
		Find elements in an array such that some condition be satisfied.
	\end{definition}
}

\subsection{Linear Search}

\frame
{
	\frametitle{Pseudocode}
	
	\begin{algorithmic}
		\Procedure{Linear Search}{$*begin, *end, target$}
			\State$result\gets\infty$
            \For{$itr\in[begin, end)$}
            	\If{$*itr\geq target\land *itr < result$}
					\State$result\gets *itr$
				\EndIf
            \EndFor
            \State\Return$result$
        \EndProcedure
	\end{algorithmic}
}

\frame
{
	\frametitle{Efficiency}
	
	If there are plenty of queries, then \textsc{Linear Search} may not fit in time limit.\pause
	
	Therefore, we could do some preprocess such as sorting and utilize the monotonicity to improve the efficiency.
}

\section{Binary Search}

\frame
{
	\frametitle{Efficient Way to Search in Ordered Sequence}
	\framesubtitle{Divide and Conquer}
	
	\begin{description}
		\item<1->[Divide]Split array into two subarrays ($b = 2, O(1)$)
		\item<2->[Conquer]Search the subarray in which the target is ($a = 1$)
		\item<3->[Combine]Nothing to do
	\end{description}
}

\frame
{
	\begin{quotation}
		``Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky.''
	\end{quotation}
	\begin{flushright}
		--- Knuth, D. E.
	\end{flushright}
}

\subsection{Typical Approach}

\frame
{
	\frametitle{Pseudocode: Recursion}
	
	\begin{algorithmic}
		\Procedure{Binary Search}{$*begin, *end, target$}
		\If{$begin = end$}
			\State\Return$begin$
		\EndIf
		\State$mid\gets\frac{begin+end}{2}$
		\If{$target < *mid$}
			\State\Return\Call{Binary Search}{begin, mid, target}
		\ElsIf{$target = *mid$}
			\State\Return$mid$
		\Else
			\State\Return\Call{Binary Search}{mid+1, end, target}
		\EndIf
        \EndProcedure
	\end{algorithmic}
}

\frame
{
	\frametitle{Tail Call \& Tail Recursion}
	
	\begin{definition}
		It's called \textbf{Tail Call} that the return statement of a function is to call some function.
		
		If the called one is the calling one itself, it's called \textbf{Tail Recursion}.
	\end{definition}
	
	\pause
	
	On top of the fact that recursion requires quite a few resources, we could use loop to attain better performance.
}

\frame
{
	\frametitle{Pseudocode: Loop}
	
	\begin{algorithmic}
		\Procedure{Binary Search}{$*begin, *end, target$}
		\While{$begin\neq end$}
			\State$mid\gets\frac{begin+end}{2}$
			\If{$target < *mid$}
    			\State$end\gets mid$
    		\ElsIf{$target = *mid$}
    			\State\Return{mid}
    		\Else
    			\State$begin\gets mid+1$
			\EndIf
		\EndWhile
		\State\Return$begin$
        \EndProcedure
	\end{algorithmic}
}

\frame{
	\frametitle{Example}
	\framesubtitle{$target=110$}
	
	\begin{center}
        \begin{tikzpicture}[scale=0.85, transform shape]
        	\only<1>{
        		\foreach \x/\val/\col in {0/8/accent,1/20/gray,2/20/gray,3/27/gray,4/27/nthu,5/27/gray,6/110/gray,7/110/gray,8/2021/gray,9//secondary}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
			\only<2>{
        		\foreach \x/\val/\col in {0/8/gray,1/20/gray,2/20/gray,3/27/gray,4/27/accent,5/27/gray,6/110/nthu,7/110/gray,8/2021/gray,9//secondary}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
			\only<3>{
        		\foreach \x/\val/\col in {0/8/gray,1/20/gray,2/20/gray,3/27/gray,4/27/gray,5/27/gray,6/110/nthu,7/110/gray,8/2021/gray,9//gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
		\end{tikzpicture}
	\end{center}
}

\subsection{Alternative Approach}

\frame
{
	\frametitle{Pseudocode}
	
	\begin{algorithmic}
		\Procedure{Binary Search}{$*begin, *end, target$}
    		\For{$n\gets end-begin, jump\gets n/2; jump>0; jump\gets jump/2$}
    			\While{$begin+jump<end\land *(begin+jump)<target$}
    				\State$begin\gets begin+jump$
    			\EndWhile
    		\EndFor
			\State\Return$begin+1$
        \EndProcedure
	\end{algorithmic}
}

\frame{
	\frametitle{Example}
	\framesubtitle{$target=110$}
	
	\begin{center}
        \begin{tikzpicture}[scale=0.85, transform shape]
        	\only<1>{
        		\foreach \x/\val/\col in {0/8/accent,1/20/gray,2/20/gray,3/27/gray,4/27/secondary,5/27/gray,6/110/gray,7/110/gray,8/2021/gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
			\only<2>{
        		\foreach \x/\val/\col in {0/8/gray,1/20/gray,2/20/gray,3/27/gray,4/27/accent,5/27/gray,6/110/gray,7/110/gray,8/2021/secondary}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
			\only<3>{
        		\foreach \x/\val/\col in {0/8/gray,1/20/gray,2/20/gray,3/27/gray,4/27/accent,5/27/gray,6/110/secondary,7/110/gray,8/2021/gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
			\only<4>{
        		\foreach \x/\val/\col in {0/8/gray,1/20/gray,2/20/gray,3/27/gray,4/27/accent,5/27/secondary,6/110/gray,7/110/gray,8/2021/gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
			\only<5>{
        		\foreach \x/\val/\col in {0/8/gray,1/20/gray,2/20/gray,3/27/gray,4/27/gray,5/27/nthu,6/110/gray,7/110/gray,8/2021/gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
		\end{tikzpicture}
	\end{center}
}

\subsection{Built-in functions}

\frame
{
	\frametitle{\ttfamily std::lower\_bound()}
	\framesubtitle{Find the minimum element that is no less than (greater than or equal to) $target$}
	
	\lstinputlisting[language=C++, firstline=36, lastline=40]{04_binary_search_builtin.cpp}
}

\frame
{
	\frametitle{\ttfamily std::upper\_bound()}
	\framesubtitle{Find the minimum element that is greater than $target$}
	
	\lstinputlisting[language=C++, firstline=41, lastline=45]{04_binary_search_builtin.cpp}
}

\frame{
	\frametitle{Examples}
	\framesubtitle{$target=110$}
	
	\begin{center}
        \begin{tikzpicture}[scale=0.85, transform shape]
        	\only<1>{
        		\foreach \x/\val/\col in {0/8/gray,1/20/gray,2/20/gray,3/27/gray,4/27/gray,5/27/gray,6/110/gray,7/110/gray,8/2021/gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
        	\only<2>{
        		\foreach \x/\val/\col in {0/8/accent,1/20/accent,2/20/accent,3/27/accent,4/27/accent,5/27/accent,6/110/gray,7/110/gray,8/2021/gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
        	\only<3>{
        		\foreach \x/\val/\col in {0/8/accent,1/20/accent,2/20/accent,3/27/accent,4/27/accent,5/27/accent,6/110/nthu,7/110/nthu,8/2021/gray}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
        	\only<4>{
        		\foreach \x/\val/\col in {0/8/accent,1/20/accent,2/20/accent,3/27/accent,4/27/accent,5/27/accent,6/110/nthu,7/110/nthu,8/2021/secondary}{
        			\node[draw=\col,rectangle, fill=\col!92, minimum size =1cm] (c) at (\x,0) {\val};
        		}
        	}
		\end{tikzpicture}
	\end{center}
}

\frame
{
	\frametitle{Examples}
	\framesubtitle{\ttfamily std::lower\_bound()}
	
	If vector $v$ is sorted:\pause
	
	\begin{itemize}
		\item Range of elements that less than $x$, $\{i\ |\ \forall i\in v\implies i<x\}$:\\\pause
		$[v.begin(), lower\_bound(v.begin(), v.end(), x))$\pause
		\item Range of elements that no less than (greater than or equal to) $x$, $\{i\ |\ \forall i\in v\implies i\nless(\geq) x\}$:\\\pause
		$[lower\_bound(v.begin(), v.end(), x), v.end())$
	\end{itemize}
}

\frame
{
	\frametitle{Examples}
	\framesubtitle{\ttfamily std::upper\_bound()}
	
	If vector $v$ is sorted:\pause
	
	\begin{itemize}
		\item Range of elements that no greater than (less than or equal to) $x$, $\{i\ |\ \forall i\in v\implies i\ngtr(\leq) x\}$:\\\pause
		$[v.begin(), upper\_bound(v.begin(), v.end(), x))$\pause
		\item Range of elements that greater than $x$, $\{i\ |\ \forall i\in v\implies i>x\}$:\\\pause
		$[upper\_bound(v.begin(), v.end(), x), v.end())$	\end{itemize}
}

\frame
{
	\frametitle{Examples}
	
	If vector $v$ is sorted:\pause
	
	\begin{itemize}
		\item Range of elements that equal to $x$, $\{i\ |\ \forall i\in v\implies i = x\}:$\\\pause
		$[lower\_bound(v.begin(), v.end(), x), upper\_bound(v.begin(), v.end(), x))$\pause
		\item Range of elements that greater than $x$ and less than $y$, $\{i\ |\ \forall i\in v\implies x < i < y\}:$\\\pause
		$[upper\_bound(v.begin(), v.end(), x), lower\_bound(v.begin(), v.end(), y))$\pause
		\item Range of elements that greater than or equal to $x$ and less than or equal to $y$, $\{i\ |\ \forall i\in v\implies x\leq i\leq y\}:$\\\pause
		$[lower\_bound(v.begin(), v.end(), x), upper\_bound(v.begin(), v.end(), y))$
	\end{itemize}
}

\frame
{
	\frametitle{Triangles}
	\framesubtitle{AtCoder Beginner Contest 143 p. D}
	
	\begin{block}{Condition to Construct a Triangle}
		Let $a, b, c$ be the three edges of the triangle, where $a\leq b\leq c$, then $b - a < c < a + b$
	\end{block}
	
	\pause
	
	Lest we may count duplicate ones, we could enumerate the shorter edges and search the range of the third edge, whose closed left end is upper bound of $b-a$ and opened right end is lower bound of $a+b$.\pause
	
	Note that because $c$ should be the longest edge, we mustn't search from $v.begin()$.
}

\end{document}
